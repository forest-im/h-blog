---
title: "스터디 정리"
tag: algorithm, JS
date: 2022-12-23 15:56:48
---

<br />
<details>
  <summary>✅ 이벤트 버블링, 이벤트 위임이란?</summary>

  - [이벤트](http://localhost:3000/posts/%08javascript/event)
</details>

<details>
    <summary>✅ 시맨틱 마크업이란?</summary>

- 의미론적 마크업
- 프로그래밍에서 시맨틱은 코드 조각의 의미를 나타낸다.
- span요소로 h1태그처럼 보일 수 있지만 span 태그 자체만으로는 의미가 없다. h1은 태그 이름 자체만으로 시맨틱 요소를 가진다. 작업에 적합한 html 태그를 사용하는 것이 좋다.
- 장점 - 시각 장애가 있는 사용자가 화면 판독기로 화면을 탐색할 때 시맨틱 마크업을 푯말로 사용할 수 있다.
</details>

<details>
  <summary>✅ Garbage collection이란?</summary>

- 자동 메모리 관리 방법.
- 저수준 언어에서는 메모리 관리를 위해 특정 메서드를 사용한다. 반면, 고수준 언어는 자동으로 메모리를 관리한다. 고수준 언어인 js는 수동으로 메모리 영역을 해제할 수 없다.
- [자바스크립트 v8 엔진의 가비지 컬렉션 동작 방식 by kakao](https://fe-developers.kakaoent.com/2022/220519-garbage-collection/)
- [V8 엔진(자바스크립트, NodeJS, Deno, WebAssembly) 내부의 메모리 관리 시각화하기 by toast](https://ui.toast.com/weekly-pick/ko_20200228)
- [node.js memory leak 메모리 누수](https://dongmin-jang.medium.com/node-js-memory-leak-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-ac32234cb9e0)


## mark-and-sweep이라 불리는

</details>

<details>
  <summary>✅ RDB란?</summary>

</details>

<details>
  <summary>✅ Hash Table</summary>

</details>

<details>
  <summary>✅ Binary Search Tree</summary>

- 이진 탐색 트리
- 이진 트리 자료 구조
- 왼쪽 노드의 값은 부모보다 작고, 오른쪽 노드의 값은 부모보다 크다.
- 좌우 하위 노드는 각각이 다시 이진 탐색 트리여야 한다.
</details>

- Sort
- 분할 정복 알고리즘
- this
- 생성자 함수
- call, apply, bind
- Promise
- async, await
- MVC, MVVM

### 개선해야 할 점

1. 말 하다가 막혔을 경우 어떻게 대처할지 연습해야 함
2. 답하기 난감한 질문의 경우 어떻게 대처할지 생각하기.
3. 자료구조 부분 구현방법도 같이 외워야 할 것 같음. 매번 할 때 마다 까먹게 됨

---

- [x] call by reference, call by value
- [x] primitive 타입과 object 타입의 차이점, 특징
- [x] 실행컨텍스트와 렉시컬 환경
- [x] 호이스팅
- [x] 클로저
- [x] 스코프
- [x] TDZ
- [ ] 1급 객체의 조건
- [ ] 브라우저의 렌더링 원리

## call by reference, call by value

- 자바스크립트에서는 call by value만 존재한다.
- 원시값은 `값 - 복사`에 의해, 합성 값(객체 등)은 `레퍼런스 - 복사`에 의해 값이 할당/전달된다.
- 자바스크립트에서의 레퍼런스는 다른 언어의 레퍼런스/포인터와는 전혀 다른 개념으로, 또 다른 변수/레퍼런스가 아닌 오직 자신의 값만을 가리킨다. 참조값 자체를 복사하여 넘기게 되므로 call by value이다.

## 원시 타입과 참조 타입의 차이점, 특징

- primitive 타입: 할당이나 연산시 복제된다.
  - 불변성을 띈다.
- reference 타입: 참조형은 주솟값을 복제한다.
  - 가변성을 띈다. 그 참조타입의 참조형 데이터 자체를 변경하는 것이 아니라 그 내부의 프로퍼티를 변경할 때만 성립ㄴ다.
  - 기본형과의 차이점은 객체의 변수 영역이 별도로 존재한다. 객체의 변수 영역에는 기본형과 똑같이 불변값의 주소가 저장되어 있지만 얼마든지 다른 값을 대입할 수 있다.

### 변수, 식별자

- 변수: 변할 수 있는 값, 변할 수 있는 값을 담는 공간.
- 식별자: 변수, 함수, 값 등을 식별할 수 있는 문자열, 공간의 이름,

### 변수, 상수

- 변수와 상수를 구분 짓는 변경 가능성의 대상은 변수 영역 메모리이다. 한 번 데이터 할당이 이루어진 변수 공간에 재할당이 이루어질 수 있는지

- string, number에는 유용한 메서드들이 있는데 그 메서드들을 쓰기 위해서는 래퍼 객체가 필요하다. 이 메서드나 프로퍼티에 접근할 때 자바스크립트 엔진이 알아서 래퍼 객체를 원시값에 박싱하여 메소드를 쓸 수 있게 되는 것이다. 메소드를 쓰고난 후에는 새로운 원시값이 반환되고 만들어진 래퍼 객체인 특별한 객체는 파괴되고 원시값만 남는다. 이런 내부 프로세스를 통해 원시값을 가볍게 유지하면서 메서드를 호출할 수 있게 된다.

## 실행컨텍스트

- 실행 컨텍스트란 실행한 코드에 대한 환경 정보를 모아놓은 객체이고 자바스크립트 코드가 실행되는 환경.
  - 함수가 실행되면 함수에 해당하는 실행 컨텍스트가 생기고, 콜 스택에 차곡 차곡 쌓인다.
  - 동일한 환경에 있는 코드를 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아올렸다가 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장한다.
  - 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경정보들을 수집해서 실행 컨텍스트 객체에 저장한다.
- 실행 컨텍스트를 구성할 수 있는 방법은, 전역 공간, eval(), 함수 실행이 있다.

  - 처음 코드를 실행시키는 순간 전역 컨텍스트가 콜 스택에 쌓인다.
  - 실행 컨텍스트를 구성할 수 있는 방법은 함수를 실행하는 것 뿐

  1. VariableEnvironment
  2. LexicalEnvironment
  3. ThisBinding

## 렉시컬 환경

- 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아놓은 것

1. environmentRecord

- 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다.
- 컨텍스트 내부 전체를 처음부터 끝까지 훑어가며 순서대로 수집한다. 이 과정에서 호이스팅이 발생한다.

2. outerEnvironmentReference

- 바로 직전 컨텍스트의 LexicalEnvironment 정보를 참조하는 것
- 식별자의 유효범위를 안에서부터 밖으로 차례로 검색해나가는 것을 스코프 체인이라고 한다.
- 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조한다.

## 호이스팅

- 변수, 함수 선언문을 선언된 위치에서 코드의 꼭대기로 끌어올리는 것을 말한다.
- 변수는 선언부와 할당부를 나누어 선언부만 끌어올리는 반면, **함수 선언은 함수 전체를 끌어올린다**.
- 스코프별로 작동한다.
- 변수의 경우 var만 해당한다.
- 먼저 함수가 끌어올려지고 다음으로 변수가 올려진다.

## 스코프

- 스코프는 선언할 때 생긴다. - lexical scope (정적 스코프)
- 식별자에 대한 유효범위
  - 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것을 **스코프 체인** 이라고 한다.
- 식별자 이름으로 변수를 찾기 위한 규칙의 집합

## 렉시컬 스코프

- 렉시컬 스코프란 함수를 어디서 선언하는지에 따라 정의되는 스코프를 말한다.

## TDZ

- 임시 데드 존
- 아직 초기화를 하지 않아서 변수를 참조할 수 없는 코드 영역
- let 블록 스코프가 대표적인 예이다.

## 1급 객체의 조건

- 변수에 할당할 수 있다.
- 파라미터로 전달할 수 있다.
- 리턴 값으로 사용할 수 있다.

## 클로저

- 클로저는 함수가 속한 렉시컬 스코프를 기억하여 함수가 렉시컬 스코프 밖에서 실행될 때에도 이 스코프에 접근할 수 있게 하는 기능을 뜻한다.
- 클로저는 렉시컬 스코프에 의해 코드를 작성한 결과로 그냥 발생한다. 모든 코드에서 클로저는 생성되고 사용된다.
- 어떤 방식으로 내부 함수를 자신이 속한 렉시컬 스코프 밖으로 수송하는 함수는 처음 선언된 곳에 스코프에 대한 참조를 유지한다. 즉 어디에서 해당 함수를 실행하든 클로저가 작용한다.

함수를 호출하는 방법에 따라 this가 결정되는데,
그 때의 this는 무엇이다

- repaint과 reflow의 차이점
- local storage, session storage, cookie. 로그인 외에 어떤 경우에 쓸수있는지, 장단점 등.
- Event loop와 js 실행 순서
- var let const 차이점
- cors의 정의와 생긴 이유, 어떻게 우회하는지
- Restful api를 왜 써야하는지 (Update 기능을 왜 Delete 메소드로 하면 안되는지)
- http와 https의 차이. 장단점
- 바벨
- 웹팩
---
title: Go!
tag: golang
date: 2023-02-07 09:46:50
published: false
---

## 조금 힘든 점
어느 부분에 초점을 맞춰야하는지 명확하지 않음
그래서 잡코리아를 봤음
클라우드 사업에서 고랑을 쓰는 사람을 많이 뽑는 것 같다
aws와 관련이 많아 보이고, ci/cd 자동화 경험이 있는 사람을 우대하고 cs지식을 원하는 것 처럼 보임

- `$ go version`
- `$ which go`
- `$ go fmt` 소스 코드 형식을 Go 표준 포맷형식으로 정렬
- `$ go run` 소스 코드를 바로 컴파일한 다음 바로 실행(컴파일된 실행 파일 저장 x)
- `$ go build` 소스 코드를 바이너리 파일로 컴파일 진행
- `fmt.Println()` 출력대상 뒤에 \n을 붙여 줄바꿈 하는 메서드
- `:=` 짧은 변수 선언 (__암시적 type__ 으로 var 선언처럼 사용될 수 있다
  - 함수 밖에서는 모든 선언이 키워드(var, func, ...)로 시작하므로 `:=`구문은 사용할 수 없다.

## 모르겠는거
- pointer

## 기본 자료형
- bool
- string
|int|uint|
|-|-|
|int, int8, int16, int32, int64|uint, uint8, uint16, uint32 uint 64 uintptr|
- byte: uint8의 별칭
- rune: int32의 별칭 (유니코드에서 `code point`를 의미한다.)
- float32, float64
- complex64, complex128
int와 uintptr type은 보통 32-bit 시스템에서는 32 bit, 64-bit 시스템에서는 64 bit의 길이이다. 정수 값 필요할 때 특정한 이유로 값을 정해야하거나 unsigned 정수 type을 사용해야 하는 게 아니라면 int를 사용해야 한다.
- 명시적인 초깃값 없이 선언된 변수는 그것의 zero value가 주어진다.
  - 숫자 type -> 0
  - boolean type -> false
  - string -> ""

### Type 변환
- `T(v)`는 v라는 값을 T type으로 변환시켜준다.

### 상수
- 상수는 변수처럼 선언, const 키워드로 선언
- 상수는 `character`, `string`, `boolean`, 숫자 값이 될 수 있다.
- 상수는 `:=`를 통해 선언될 수 없다.

### 숫자형 상수
- 숫자형 상수는 매우 정확한 값이다.
- type이 정해지지 않은 상수는 문맥에서 필요한 type을 취한다.

main 패키지에서 실행 시작
fmt, math/rand 패키지 사용
관습적 - 패키지 이름은 import 경로의 마지막 요소와 같다.
- math/rand -> package rand 문으로 시작하는 파일들로 구성되어있다.

Go에서는 대문자로 시작하는 이름이 export 된다.
pacakge를 import할 때, 패키지의 export된 이름들만 참조할 수 있다. export되지 않은 이름들에는 패키지의 밖에서 접근할 수 없다.

변수 이름 뒤에 type이 온다. -> c와 다름
  - c는 앞에 type이 온다. 복잡해지면 왼쪽에서 오른쪽으로 읽을 때 가독성이 좋지 않음
  - type이 뒤로 오게 함으로써 왼쪽에서 오른쪽으로 나열하는 스타일의 장점은 유형이 복잡해질수록 장점이 강화된다.

두 개 이상의 연속된 이름이 주어진 함수 매개변수가 같은 type일 때 마지막 제외하고 type 생략 가능

var 문은 변수에 대한 목록을 선언한다. 마지막은 type
var 문은 package나 함수 단에 존재할 수 있다.

## 반복문
- Go는 `for` 단 하나의 반복 구조를 가진다.
- 주의: 다른 언어들과 달리 세 가지 구성 요소를 감싸는 괄호가 없고, `{ }`항상 필수

- `;`으로 구별되는 세 가지 구성 요소를 가진다.
1. 초기화 구문: 첫 번째 이터레이션 전에 수행
  - 주로 짧은 변수 선언, 여기서 선언된 변수들은 for문의 스코프에서만 보여짐
2. 조건 표현: 모든 이터레이션 이전에 판별
  - 조건 판별의 boolean값이 false면 이터레이팅 종료
3. 사후 구문: 매 이터레이션 마지막에 수행

```go
func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}
```

- 초기화 구문과 사후 구문은 필수 아님
- ';' 생략하고 조건 표현만 쓰면 C의 while처럼 쓸 수 있다.

```go
func main() {
	sum := 1
	for ; sum < 1000; {
		sum += sum
	}
	fmt.Println(sum)
}

func main() {
	sum := 1
	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}

```

## if
- Go의 if문은 for와 비슷, `()`괄호로 둘러쌓일 필요는 없지만, `{}`괄호는 필수
- `for`문과 마찬가지로, `if`문 또한 조건문 전에 수행될 짧은 구문으로 시작될 수 있다.
```go
func pow(x, n, lim float64) float64 {
  if v := math.Pow(x, n); v < lim {
    return v
  }
  return lim
}

func main() {
  fmt.Println(
    pow(3, 2, 10),
    pow(3, 3, 20),
  )
}
```

- 짧은 `if`문 안에서 선언된 변수들은 어떠한 else 블럭에서든 사용이 가능하다.
```go
func pow(x, n, lim float64) float64 {
  if v := math.Pow(x, n); v < lim {
    return v
  } else {
    fmt.Printf("%g >= %g\n", v, lim)
  }
  // can't use v here, though
  return lim
}

func main() {
  fmt.Println(
    pow(3, 2, 10),
    pow(3, 3, 20),
  )
  // 27 >= 20
  // 9 20
}
```

### 제곱근 (square root)
- 제곱근 또는 루트라고 읽는다.
- 제곱의 반대
- 제곱해서 a가 되는 실수를 모두 a의 제곱근(루트 a)라고 부른다. 기호로는 √를 사용한다.
- 25의 제곱근은 5, -5
- 컴퓨터는 주로 x의 제곱근을 반복문을 사용해 연산한다. 어떠한 추측 값 z로부터 시작해, z^2가 x에 얼마나 가까운 가를 근거로 z의 더 좋은 값을 추정한다.

```js
package main

import (
	"fmt"
)

func Sqrt(x float64) float64 {
	z := 1.0
	for i := 1; i < 10; i++ {
		fmt.Println(z, "wow")
		z -= (z*z - x) / (2 * z)
	}

	return z
}

func main() {
	fmt.Println(Sqrt(25))
}
```

## Switch
- `switch` 구문은 연속적인 if-else 구문을 사용하는 짧은 방안
- 다른 언어와의 차이점 - Go에서는 자동으로 `break`구문이 제공됨, Go의 케이스는 상수일 필요도 정수일 필요도 없다.

### 조건이 없는 Switch
- 이 구조는 긴 if-else 체인을 작성하는 데에 좋을 수 있음.

```go
  package main

  import (
    "fmt"
    "time"
  )

  func main() {
    t := time.Now()
    switch {
      case t.Hour() < 12:
        fmt.Println("Good morning!")
      case t.Hour() < 17;
        fmt.Println("Good afternono!")
      default:
        fmt.Println("Good evening!")
    }
  }
```

## Defer
defer 문은 자신을 둘러싼 함수가 종료할 때까지 어떠한 함수의 실행을 연기한다.
연기된 호출의 인자는 즉시 평가되지만 그 함수 호출은 자신을 둘러싼 함수가 종료할 때까지 수행되지 않는다.

```js
func main() {
  defer fmt.Println("world")

  fmt.Println("hello")
}
```

```js
  func main() {
    fmt.Println("counting")

    for (i := 0; i < 10; i++) {
      defer fmt.Println(i)
    }

    fmt.Println("done")
  }
```


## Pointers
- Go는 포인터를 지원한다. 포인터는 값의 메모리 주소를 가지고 있다.
- `*T`타입 : T 값을 가리키는 포인터. 이것의 zero value는 nil 이다.
- `var p *int`
- `&`연산자는 이것의 피연산자에 대한 포인터를 생성한다.
```js
  i := 42
  p = &i
```
- * 연산자는 포인터가 가리키는 주소의 값을 나타낸다.
```js
  fmt.Println(*p) // 포인터 p를 통해 i 읽기
  *p = 21 // 포인터 p를 통해 i 설정
```
  - 이것은 "역 참조" 또는 "간접 참조"로 알려져 있다.

## Structs (구조체)
- 구조체는 필드의 집합체
- 구조체는 코드의 결합도, 의존성을 낮게 만들고 응집도를 높게 만드는 역할을 한다.

```js
  type Vertex struct {
    X int
    Y int
  }

  func main() {
    fmt.Println(Vertex{1, 2}) // {1, 2}
  }
```

- 구조체의 필드는 `.{dot}`으로 접근할 수 있다.

```js
  type Vertex struct {
    X int
    Y int
  }

  func main() {
    v := Vertex{1, 2}
    v.X = 4
    fmt.Println(v.X) // 4
  }
```



모듈?

Go에서는 문자열에 작은 따옴표를 사용할 수 없음

동적 언어 -> javascript
정적 언어
  - 정적 언어들이 제공하는 타입 안정성을 제공하지 않는다.``
동적 언어, 정적 언어 차이점은?

## 고루틴 goroutine
프로그램의 진입점(entry point)함수를 비롯하여 다른 고루틴과 함께 동시에 실행되는 함수다.
다른 프로그래밍 언어의 경우 이런 일을 가능하게 하려면 스레드를 사용해야 하지만, Go에서는 여러 개의 고루틴이 하나의 스레드에서 동작한다. Go는 고루틴을 이용한 동시성 기능을 자체적으로 지원하는 net/http 라이브러리를 사용한다. 그러면 서버로 유입된 각각의 요청들이 자동적으로 각자의 고루틴에서 동작하게 된다. 고루틴은 스레드보다 적은 메모리를 사용하며 Go 런타임이 설정된 논리 프로세서의 개수에 따라 자동적으로 고루틴을 실행하기 위한 스케줄링을 처리한다. 그리고 각각의 논리 프로세서는 하나의 OS 스레드에 연결된다.

## 포트 종료하기
`lsof -i -nP` `kill PID`

---
어셈블리어 등장 : 이제 인간이 읽을만한 언어

어셈블리어는 op코드를 하나 하나 명령해줘야하는 단점
고수준 언어 등장
  - 어셈블리어 제외하고 나머지 언어
  - 인간의 언어 문법과 유사하게 프로그래밍

결국에는 컴터에서 실행되려면 컴파일해서 기계어로 바뀌어야 한다.

정적 컴파일 언어
- 코드를 실행하기 전에 미리 기계어로 바꾸어 놓는 것 (실행 파일 (.exe))
- 실행할 때 바꾸지 않아도 기계어로 바뀌는 절차가 없어 속도가 빠르다.
- c, c++, go
- op코드가 index, arm... 이런 것들 마다 다른데 미리 컴파일하려면 어떤 운영체제인지에 따라 다 나누어 컴파일해놔야 한다. -> 복잡하다.
- 예전에는 플랫폼 종류가 많았는데 지금은 좀 단순해져서 go는 다시 정적언어를 택했다.

동적 컴파일 언어
- 정적 문제점을 해결하고자 나왔따.
- 실행 할 때마다 바꾸는 것
- 속도가 정적보다 느리다.
- java, python, javascript
- 동일한 코드만 다운받으면 실행하는 시점에 플랫폼을 분석하여 그 때 그 때 변환. 똑같이 실행될 수 있도록 하자

약타입 언어 vs 강타입 언어
`"12" + 12 = "1212"` -> 약타입 언어 (타입 검사를 잘 안한다.)

go는 최강타입 언어!
타입이 다르면 연산 안됨 -> 귀찮다.
타입이 다르면 생기는 문제들이 미연에 방지된다.

가비지 컬렉터 유무
  - 가비지 컬렉터가 성능에 문제를 조금 끼친다. (메모리를 먹음)

go

정적 컴파일 언어
강타입 언어
가비지 컬렉터 유
2009년, 구글에서 만들어진 오픈 소스 프로그래밍 언어
켄톰슨이 b언어 만든 사람이라 go는 c와 조금 닮아있다.

켄 톰슨 롭 파이크 -> UTF-8 만듦
go는 UTF-8이 기본 문자 인코딩

왜 문자 인코딩이 필요하냐
  - 컴터는 1, 0밖에 모르는데 어케 문자를 알겠냐 문자를 숫자로 바꿔줘야해 컴퓨터간의 약속을 문자 코드로 만든 것
  - ANSI라는 게 잇는데 옛날에 영어만 표현했어 1byte로 영어를 표현했으. 0 ~ 255개의 문자 영어바께 안되니까 많은 문제 생김 -> UNICODE-16, UNICODE중에 하나인 UTF-8 유니코드는 2바이트 UTF-8은 1 ~ 3바이트


Go -> oop언어

|개념|있다/없다|설명|
|-|-|-|
|클래스|없다|클래스는 없지만 메서드를 가지는 구조체를 지원한다|
|메서드|있다|구조체가 메서드를 가질 수 있다|
|인터페이스|있다|상속이 없지만 인터페이스는 있다|
|익명 함수|있다|함수 리터럴이라는 이름으로 제공|
|가비지 컬렉터|있다|고성능 가비지 컬렉터 제공|
|포인터|있다|메모리 주소를 가리키는 포인터 있다|
|제네릭 프로그래밍|없다|지원 x|
|네임스페이스|없다|네임스페이스 지원x, 모든 코드는 패키지 단위로 분리된다|

go mod init hello2
go.mod

고의 모든 코드는 무조건 패키지로 시작해야한다.
패키지는 코드를 묶는 단위다. 이 코드가 무슨 패키지에 있는 코드인가 라는 의미

main -> 특별한 키워드 의미가 있다. 
  - 프로그램 시작점을 포함하는 패키지
  - 시작부분은 하나여야 한다.
  - main 패키지 하나랑 나머지 여러 개로 구성됨

## 변수
- 변수 값을 저장하는 메모리 공간을 가리키는 이름
- 프로그램이란 결국 데이터를 연산/조작 하는 일
- 메모리에서 값을 가져옴 (cpu에서 계산하는 데 필요한 데이터는 메모리에서) 조작하는 일은 모두 변수를 통해 일어난다. 가장 기본적인 데이터의 조작은 변수를 통해서 한다.
- 프로그래밍의 가장 기초적인 부분
- 프로그램이란 결국 데이터를 연산/조작하는 일 - 숫자가 계산된다.

`var a int = 10`

### 변수 4가지 속성
1. 이름
2. 값
3. 주소
4. 타입
  - 타입은 사이즈를 가지고 있다. 타입을 알면 사이즈를 알 수 있다.
  - 공간의 시작 지점은 주소를 이용해 알 수 있다. 끝은 타입이 알고있다. (사이즈)
  - 타입의 사이즈는 고정이다.

## 숫자 타입
1. 정수
2. 실수

- uint8 (unsigned integer 부호 없는 정수 즉 양수다) 8비트 -> 1byte
- uint16, uint32, uint64
- int8, int16, int32, int64 (부호 있는 실수)
- float32, float64

- byte -> uint8과 같다. (별칭을 붙인 것)
- rune -> 문자 1개 (rune이 모이면 string이 된다.)
  - UTF-8 (문자 1개 -> 1 ~ 3byte 문자열: 길이가 3byte이상 컴터는 2진수라서 1, 2, 4, 8이런 식으로 늘어난다)
  - int32의 별칭 타입 즉 4byte로 표현할 수 있다. 문자 1개가 3byte까지니까 4바이트로 충분히 담을 수 있다.
- int
  - 사이즈가 플랫폼에 따라 달라진다.
  - 32비트 컴터 -> int === int32
  - 64비트 컴터 -> int === int64
- uint
  - int와 개념은 같음

## 그 외 타입
- bool
- string
- 배열
- 슬라이스
- 구조체
- 포인터
- 함수타입
- 맵
- 인터페이스
- 채널

## 별칭 타입
- 새로운 타입을 만들 수 있음

## 변수 선언법
```js
  var a int = 10
  var a int
  var a = 10 //a는 뒤의 값과 타입이 같아진다. 타입 생성하려면 반드시 초깃값 필요
  a := 10

```

## 타입별 기본값
|타입|기본값|
|-|-|
|모든 정수 타입|0|
|모든 실수 타입|0.0|
|불리언|false|
|문자열|""|
|그 외|nil(정의되지 않은 메모리 주소를 나타내는 Go 키워드|

## 타입 변환
연산의 각 항목의 타입은 반드시 같아야 한다.
```js
var a int = 10
var b int16 = 20

// a + b -> 안됨
```

```js
package main

import "fmt"

func main() {
	a := 3
	var b float64 = 3.5

	var c int = int(b) // 타입 변환
	d := float64(a) * b

	var e int64 = 7
	f := a * int(e)

	fmt.Println(a, b, c, d, e, f) // 3 3.5 3 10.5 7 21
}
```
- 타입 변환도 다 되는 건 아니고, go가 허용하는 것만 됨

### 타입 변환 주의사항
- float64 에서 int : 소수점 날라감
```js
package main

import "fmt"

func main() {
  var a int16 = 3456
  var b int8 = int8(a) //int16 -> int8로 변환

  fmt.Println(a, b) // 3456 -128
}

[0 0 0 0 1 1 0 1 ] [1 0 0 0 0 0 0 0 ] a int16 = 3456
// 밑으로 변환
[                ] [1 0 0 0 0 0 0 0 ] c int8 = -128

상위 1바이트가 없어진다!
```
- 큰 그릇에 있던 걸 작은 그릇에 옮기면 나머지는 버려진다.

|이름|설명|값의 범위|
|-|-|-|
|uint8|1바이트 부호 없는 정수|0 ~ 255|
|uint16|2바이트 부호 없는 정수|0 ~ 65535|
|uint32|4바이트 부호 없는 정수|0 ~ 4294967295|
|uint64|8바이트 부호 없는 정수|0 ~ 18446744073709551615|
|int8|1바이트 부호 있는 정수|-128 ~ 127|
|int16|2바이트 부호 있는 정수|-32768 ~ 32767|
|int32|4바이트 부호 있는 정수|-2147483648 ~ 2147483647|
|int64|8바이트 부호 있는 정수|-9223372036854775808 ~ 9223372036854775807|
|float32|4바이트 실수|IEEE-754 32비트 실수|
|float64|8바이트 실수|IEEE-754 64비트 실수|
|complex64|8바이트 복소수(진수, 가수)|진수와 가수 범위는 float32 범위와 같음|
|complex128|16바이트 복소수(진수, 가수)|진수와 가수 범위는 float64 범위와 같음|
|byte|uint8의 별칭, 1바이트 데이터를 나타낼 때 사용|0 ~ 255|
|rune|int32의 별칭, UTF-8로 문자 하나를 나타낼 때 사용|-2147483648 ~ 2147483647|
|int|32비트 컴퓨터에서는 int32, 64비트 컴퓨터에서는 int 64와 같음||
|uint|32비트 컴퓨터에서는 uint32, 64비트 컴퓨터에서는 uint64||

- int는 음수 양수가 나눠서 8바이트를 나눠쓰기 때문에 uint에 비해 범위가 각각 반절이다.

## 2진수 정수 표현
```
   0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 = 15
   |                         2^3 = 8
   |                           2^2 = 4
   |                             2^1 = 2
   v                               2^0 = 1
부호 비트                    8 + 4 + 2 + 1 = 15
```
## 10진수 정수 표현
```
3456
3 x 10^3 + 4 x 10^2 + 5 x 10^1 + 6 x 10^0
3000 + 400 + 50 + 6 = 3456
```

## 2진수 실수 표현
```
152.345 = 0.152345 x 10^3 -> 지수 표현이라고 한다.
-> 152345와 3만 알면 모든 실수를 표현할 수 있다.
```

```
float64
  0   1 0 0 0 0 0 0      0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  |         |                               |
  v         v                               v
부호 비트   지수부 (8비트)                    소수부 (23비트)

숫자인 소수부의 비트가 고정되어 있다.

367812           4
숫자부 = 소수부    지수부
= 0.367812 x 10^4
```

|타입|최솟값|최댓값|소수부|
|-|-|-|-|
|float32|1.175494351e-38 (x 10^-38)|3.402823466e38 (x 10^38)|7자리|
|float64|2.2250738585072014e-308 (x 10^-308)|1.7976931348623158e308(x 10^-308)|15자리|
- 중요한 점은 소수부가 고정되어있다는 점

```js
package main

import "fmt"

func main() {
	var a float32 = 1234.523
	var b float32 = 3456.123
	var c float32 = a * b
	var d float32 = c * 3

	fmt.Println(a) // 1234.523
	fmt.Println(b) // 3456.123
	fmt.Println(c) // 4.266663e+06
  // 7자리만 살아있고 뒷자리는 짤림
	fmt.Println(d) // 1.2799989e+07
  // 위와 오차가 3배 커짐
}
```

## fmt 

### 표준 입출력 standard input/output

```
모니터   <-

프린터   <-               <-- 출력
              표준 입출력             프로그램
와이파이  <-               --> 입력

키보드   <-
```

### 표준 출력 함수

|||
|-|-|
|Print()|함수 입력값들을 출력한다.|
|Println()|함수 입력값들을 출력하고 개행한다.|
|Printf()|서식(format)에 맞도록 입력값들을 출력한다.|

```js
package main

import "fmt"

func main() {
	var a int = 10
	var b int = 20
	var f float64 = 32799438743.8297

	fmt.Print("a: ", a, "b: ", b) // a: 10b: 20
	fmt.Println("a:", a, "b:", b, "f:", f) // a:  10 b:  20 f:  3.27994387438297e+10
  // 지수표현으로 표시됐다. 뒤 e+10은 10^10을 곱하면 원래 값이 나온다는 뜻
	fmt.Printf("a: %d b: %d f: %f\n", a, b, f)
  // a: 10 b: 20 f: 32799438743.829700

	// %d = decimal 정수
	// %f = float 실수 타입
}
```

### 서식 문자
- `%v`: 데이터 타입에 맞춰서 기본 형태로 출력한다.
- `%5d`: 5칸에 맞춰서 출력
- `%05d`: 빈칸에 0을 넣어라 0 0 1 2 3   0 0 4 5 6
- `%-5d`: 1 2 3 . .   4 5 6 . .

### scan

|||
|-|-|
|Scan()|표준 입력에서 값을 입력받는다.|
|Scanf()|표준 입력에서 서식 형태로 값을 입력받는다.|
|Scanln()|표준 입력에서 한 줄을 읽어서 값을 입력받는다.|

`fmt.Scanln(&a, &b)`
- &a : a의 주소값을 나타낸다.

### 입력 버퍼
입력된 값을 임시 저장
버퍼를 비워줘야 한다.
ReadString("\n")
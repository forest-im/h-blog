---
title: 모듈
tag: JS
date: 2023-01-28 19:44:00
published: false
---

> TL:DR
> 처음 만들어진 js에는 모듈이 없었다. html에 js 원본 소스를 제공하고 브라우저에서 순서대로 로드하는 방식이었음 이러다 보니 모듈 간 스코프가 구분되지 않아 다른 파일을 오염시키는 일이 발생함. -> "모듈화"에 대한 필요성이 떠오르고 만들어진 게 "Common JS(동기, 비동기 불가능), AMD(비동기 가능)" 브라우저는 js파일을 저장하지 못하고 매번 불러와야 했기 때문에 언제나 로딩과 비동기를 고려해야 했다. Common JS는 비동기 지원이 되지 않아서 브라우저에서 사용할 수 없었기 때문에 AMD 방식 사용 (단점이 있어 널리 쓰이지는 않았음), commonJS를 브라우저에서도 사용할 수 있게 만든 최초 빌드 도구인 Browserify 탄생. node js는 common js 채택. (Common js 모듈 시스템은 node.js 프로젝트에서는 훌륭한 해결책이었지만 브라우저에게는 그렇지 않았음) -> ES6 모듈 탄생 (공식 표준 모듈 시스템이 명시됨)

es6 등은 비교적 최근에 정의된 문법이다 보니 구형 브라우저에서 제대로 동작 x -> 모듈 시스템을 모두 지원하는 또 다른 형태의 모듈 로더가 나옴(모듈을 런타임에 로드할 수 있게 만드는 역할) -> es6에서 js 표준 모듈 문법이 정의되었음에도 불구하고 es6 문법을 구형 브라우저에서 사용하지 못해 모듈로더라는 다른 라이브러리에 의존하는 것은 꽤나 꺼림칙한 일이었다고 함 -> 트랜스파일러 탄생 (한 번 컴파일하면 구형 브라우저에서도 동작하는 js 코드가 나오게 만드는 도구(Babel 같은))

자바스크립트는 모듈 없이 태어났다.
html에서 js 원본 소스를 제공하고 브라우저에서 순서대로 로드하는 방식

commonjs
브라우저 외의 환경에서도 동작하는 범용적인 javascript를 위한 모듈 시스템
동기적으로 모듈을 호출한다. 비동기 방식보다 느리다
CommonJS 모듈 시스템은 node.js 프로젝트에 있어서는 훌륭한 해결책이지만 브라우저에게 있어서는 그렇지 않음(비동기 로드가 안돼서 브라우저에서 사용 x)
-> 브라우저 단에서도 commonjs 모듈 방식을 활용하기 위한 최초 빌드 도구인 `Browserify` 탄생

## ES6 Module

2015년 js 표준 모듈 시스템이 명시되었다.
동기/비동기 로드를 모두 지원
CommonJS와는 다르게 실제 객체/함수를 바인딩하기 때문에 순환 참조 관리도 편하다.

## 모듈 로더

- js 모듈을 런타임에 로드할 수 있게 만드는 구현체
- AMD의 모듈 로더는 Require JS, ES6 방식의 모듈 로더는 네이티브 브라우저

## 트랜스파일러

ES6에서 js 표준 모듈 문법이 정의되었음에도 불구하고, es6 문법을 구형 브라우저에서 사용하지 못해서 나온 아이디어가 바로 트랜스파일러 (Babel같은 것들)
-> 즉 한 번 컴파일하면 구형 브라우저에서도 동작하는 js 코드가 나오게 만드는 도구

---

지금까지 CommonJS와 AMD, UMD 방식으로 모듈 시스템에 대해 이야기한 것은 바로 스코프가 구분되는 모듈을 만들기 위함이었다.
그렇다면 스코프가 구분되는 모듈을 만드는 목적은?? -> 여러 모듈을 조합해 중복되는 코드를 줄이면서도, 생산성과 퍼포먼스가 뛰어난 애플리케이션을 만들기 위함

## 태스크 러너

"코드 작성 - 컨벤션 유지 위해 린트 사용 (Sass, TS 전처리가 필요한 언어 컴파일) -> 소스 코드 축소(minify) 후 하나의 파일로 묶는 과정(bundle)"

- 이 과정의 반복을 자동화하는 것 : 태스크 러너
- 즉 태스크 러너는 프로덕트 개발 과정에서 필요한 일련의 과정들을 자동화하기 위한 도구

## 모듈 번들러

- 빌드를 위한 태스크 러너의 한 과정이었던 번들을 좀 더 전문적으로 도와주는 도구가 필요해졌음 -> 모듈 번들러의 등장
- js 모듈을 브라우저에서 실행할 수 있는 단일 js 파일로 번들링 하는 데 사용되는 프론트엔드 개발 도구
- webpack, rollup, parcel.js(스벨트 개발한 리치 해리스가 만듦)

## 모듈 로더 vs 모듈 번들러

<div class="table-wrapper">

| 모듈 로더                                     | 모듈 번들러                                                                               |
| --------------------------------------------- | ----------------------------------------------------------------------------------------- |
| 일반적으로 런타임에 모듈을 가져오기 위한 목적 | 빌드 시 모듈을 묶어서 단일 번들 파일로 만든다. (런타임에서 추가적인 로드를 할 필요 없다.) |

</div>

> 번들러 사용 이유

1. 아직까지 모든 브라우저가 모듈 시스템을 완전하게 지원하지 않음
2. 코드의 종속성 관계를 관리하는 데 도움이 된다.
3. 종속성 순서, 이미지, CSS 에셋 등을 로드하는 데 도움이 된다.

- 번들러가 처음 만들어진 이유는 js 모듈을 브라우저에서 실행할 수 있는 단일 js파일로 번들링 하기 위함이었지만 사용하지 않는 코드를 제거하는 등의 최적화 작업에 대한 필요성도 높아짐

> 출처

- [JavaScript 번들러로 본 조선시대 붕당의 이해](https://yozm.wishket.com/magazine/detail/1261/)

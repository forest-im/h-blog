---
title: 모던자바스크립트 - 식별자
tag: 책, JS, 모던 자바스크립트
date: 2022-12-30 14:59:07
---

- [변수](#변수)
- [식별자](#식별자)
- [숫자](#숫자)
- [undefined](#undefined)
- [변수 호이스팅](#변수-호이스팅)
- [문과 표현식](#문과-표현식)
  - [문](#문)
  - [표현식](#표현식)
- [타입 변환](#타입-변환)
  - [암묵적 타입 변환 (Implicit coercion, Type coercion)](#암묵적-타입-변환-implicit-coercion-type-coercion)
  - [명시적 타입 변환](#명시적-타입-변환)
  - [Falsy 값](#falsy-값)
  - [Truthy 값](#truthy-값)

## 변수

변수는 값의 위치(주소)를 기억하는 저장소. 즉 변수란 값이 위치하고 있는 메모리 주소에 접근하기 위해 사람이 이해할 수 있는 언어로 명명한 식별자(identifier)이다.

## 식별자

식별자는 어떤 대상을 유일하게 식별할 수 있는 이름을 말한다. 식별자에는 변수명, 함수명, 프로퍼티명, 클래스명 등이 있다.

- 식별자는 데이터가 저장된 메모리 상의 주소를 기억한다. 따라서 식별자를 통해 메모리에 저장된 값을 참조할 수 있다.

## 숫자

자바스크립트의 숫자 타입은 정수만을 위한 타입이 없고 모든 수를 실수로 처리한다. 정수로 표시된다해도 사실은 실수다. (프로그래밍 언어에서 실수는 일반적으로 소수를 가리킨다.)

## undefined

undefined 타입의 값은 undefined가 유일하다. 선언 이후 값을 할당하지 않은 변수는 undefined값을 가진다. 이는 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이루어질 때까지 빈 상태로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화 하기 때문이다.

- undefined는 개발자가 의도적으로 할당한 값이 아니라 자바스크립트 엔진에 의해 초기화된 값이다. 변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 값이 할당된 적이 없는 변수라는 것을 간파할 수 있다. 이 값을 개발자가 마음대로 할당한다면 본래이 취지와 어긋날 수 있으므로 권장하지 않는다. 변수의 값이 없다는 것을 명시하고 싶을 때는 null을 할당한다.

## 변수 호이스팅

- 모든 선언문은 호이스팅된다.
- 자바스크립트는 모든 선언문이 선언되기 이전에 참조 가능하다.
- 호이스팅이란 var 선언문이나 function 선언문 등 모든 선언문이 해당 scope의 선두로 옮겨진 것처럼 동작하는 특성을 말한다.
- 변수는 3단계에 걸쳐 생성된다.

1. 선언 단계

- 변수 객체에 변수를 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다.

2. 초기화 단계

- 변수 객체에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화된다.

3. 할당 단계

- var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 따라서 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다.

## 문과 표현식

|               | 역할                                                      |
| ------------- | --------------------------------------------------------- |
| 문(statement) | 표현식으로 생성한 값을 사용해 컴퓨터에게 명령을 내리는 것 |
| 표현식        | 값을 생성하는 것                                          |

### 문

```js
var x; // 변수 선언문
// 선언문은 값으로 사용할 수 없다.

x = 5; // 변수 할당문
...

```

### 표현식

- 표현식의 역할은 값을 생성하는 것
- 표현식은 그 자체로 하나의 문이 될 수도 있다.
- 표현식은 평가되어 값을 만들지만 그 이상의 행위는 할 수 없다.

## 타입 변환

- 자신이 작성한 코드에서 암묵적 타입 변환이 발생하는지.. 등등 예측 가능해야 한다. 꼭 명시적 타입 변환만을 사용해야 좋은 것은 아니다. 다만 자신의 코드는 타인에 의해 쉽게 이해될 수 있어야 한다.

### 암묵적 타입 변환 (Implicit coercion, Type coercion)

- 암묵적 타입 변환은 변수 값을 재할당해서 변경하는 것이 아니라 자바스크립트 엔진이 표현식을 에러없이 평가하기 위해 기존 값을 바탕으로 새로운 타입의 값을 만들어 단 한번 사용하고 버린다.

1. 문자열 타입으로 변환 (문자열 연결 연산자)
   `1 + '2'`

- 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다.

2. 숫자 타입으로 변환

- 산술 연산자

```js
1 - '1'; // 0
1 * '10'; // 10
1 / 'one'; // NaN
```

- 비교 연산자

```js
'1' > 0;
```

- 비교 연산자의 역할은 불리언 값을 만드는 것이다. : 비교 연산자는 피연산자의 크기를 비교하므로 피연산자는 컨텍스트 상 숫자 타입이어야 한다.

- 단항 연산자

```js
+'' + // 0
  '0' + // 0
  '1' + // 1
  'string' + // NaN
  true + // 1
  false + // 0
  null + // 0
  undefined + // NaN
  Symbol() + // TypeError: Cannot convert a Symbol value to a number
  // 객체 타입
  {} + // NaN
  [] + // 0
  [10, 20] + // NaN
  function () {}; // NaN
```

3. 불리언 타입으로 변환

- 자바스크립트 엔진은 제어문의 조건식 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.

### 명시적 타입 변환

- 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다.

1. 문자열 타입으로 변환

- String 생성자 함수를 new 연산자 없이 호출하는 방법
- Object.prototype.toString 메소드를 사용하는 방법
- 문자열 연결 연산자를 이용하는 방법

2. 숫자 타입으로 변환

- Number 생성자 함수를 new 연산자 없이 호출하는 방법
- parseInt, parseFloat 함수 이용(문자열만 변환 가능)
- 단항 연산자 사용
- 산술 연산자 사용

3. 불리언 타입으로 변환

- Boolean 생성자 함수를 new 연산자 없이 호출
- !부정 논리 연산자를 두 번 사용

### Falsy 값

- false
- null
- undefined
- 0, -0
- NaN
- 빈문자열

### Truthy 값

- Falsy 값 이외의 값은 모두 Truthy 값이다.

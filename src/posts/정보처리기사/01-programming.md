---
title: C++, JAVA, Python 기본 정리
tag: 정보처리기사
date: 2023-06-26 20:15:49
---

## 데이터 타입

불린 : C언어에서는 미지원
문자: char
문자열: C언어는 char 배열을 사용하여 구현
정수 타입: int
부동 소수점: float, double

변수: 그 값을 주 기억장치에 기억하기 위한 공간이다.

- 자료형과 변수명을 작성하여 변수를 생성하는 노가정이다.
- C, C++, 자바에서는 변수 선언을 하고, 파이썬에서는 별도로 변수 선언을 하지 않는다.

## 배열: 배열은 같은 타입의 변수들로 이루어진 집합이다.

### C, C++언어의 배열 선언

- 초깃값이 있는 경우: `타입 배열명[배열_요소_개수] = {초깃값}`
- 초깃값이 명시되지 않은 값들은 자동으로 0으로 초기화된다.

```c
int a[5] = {1, 2};

// 배열 요소 개수는 5개이므로 5개의 공간이 잡히고, 초깃값은 1, 2로 두 개만 명시되어 있으므로 나머지 3개의 공간은 0으로 초기화
```

### 자바 언어의 배열 선언

- 초깃값이 없는 경우: `타입 []배열명 = new 타입[배열_요소_개수];`
- 초깃값이 있는 경우: `타입 []배열명 = {초깃값};`
- 초깃값을 선언하지 않을 경우 정수일 때는 0, 실수일 때는 0.0, 문자열일 때는 NULL(0)이 저장되어 있다.

## 포인터

포인터는 변수의 주솟값을 저장하는 공간이다.

### 포인터 선언

- `데이터_타입* 포인터_변수명 = &변수명;`
- 데이터 타입 뒤에 \*를 붙이면 주소를 저장하는 포인터 변수라는 의미이고, 일반 변수명에 &를 붙이면 해당 변수명의 주솟값이다.

```c
int a = 10;
int* b = &a;
printf("%d %d", a, *b); // b가 가리키는(*) 값은 a이므로 *b와 a는 값이 같다.
```

## 자료형

### 자바 자료형

- HashSet
  - HashSet은 Set의 하위 클래스로 중복된 원소를 허용하지 않는 집합의 성질을 가지고 있는 자료형이며 클래스이다.
  - 순서 중요 X
  - `Set 변수명 = new HashSet();`
  - `HashSet 변수명 = new HashSet();`
  - `add(값)`, `remove(값)`, `size()`
- ArrayList

  - ArrayList는 List의 하위 클래스로 크기가 가변적으로 변하는 선형리스트의 성질을 가진 클래스이다.
  - 순서 중요(인덱스 통해 접근 가능)
  - `List 변수명 = new ArrayList()`
  - `ArrayList 변수명 = new ArrayList();`
  - `add(값)`: 값을 추가
  - `add(인덱스, 값)`: 해당 인덱스에 값을 추가
  - `remove(인덱스)`
  - `get(인덱스)`
  - `size()`

- HashMap
  - HashMap은 키와 값으로 구성된 객체를 저장하는 구조로 되어 있는 자료구조를 구현한 자료형이며 클래스이다.
  - `Map 변수명 = new HashMap();`
  - `HashMap 변수명 = new HashMap();`
  - `put(키, 값)`
  - `remove(키)`
  - `get(키)`
  - `size()`

## 파이썬

### 파이썬 자료형

- 세트(Set)형
  - 세트형은 중복된 원소를 허용하지 않는 집합의 성질을 가지고 있는 자료형이다.
  - `세트명 = set([요소1, 요소2, ...])`
  - `세트명 = {요소1, 요소2, ...}`
  - `add(값)`
  - `update([값1, 값2, ...])`
  - `remove(값)`

```python
s = {1, 5, 7}

s.add(3)
s.add(5)
s.update([1, 2, 3, 4]) # s에 1, 2, 3, 4를 한 번에 추가하지만 1과 3은 이미 있으므로 2, 4만 추가
```

- 리스트형

  - 리스트는 크기가 가변적으로 변하는 선형리스트의 성질을 가지고 있는 자료형이다.
  - `리스트명 = [요소1, 요소2, ...]`
  - `append(값)`: 리스트 마지막 요소 뒤에 값을 추가하는 메서드
  - `insert(인덱스, 값)`: 리스트의 인덱스 위치에 값을 추가
  - `remove(값)`: 리스트에서 해당하는 값을 제거하는 메서드. 해당하는 값이 여러 개 있을 경우 가장 앞에 있는 값을 제거

- 리스트 인덱싱
  - 리스트가 n개의 값을 가질 때 인덱스는 다음과 같다.
  - 첫 번째 요소: 0, -n
  - 두 번째 요소: 1, -(n-1)
  - 뒤에서 두 번째 요소: (n-2), -2
  - 마지막 요소: (n-1), -1

```python
a = [4, 2, 7, 3, 5]
```

- 4: `a[0]`, `a[-5]`

- 리스트 슬라이싱
  - 리스트 슬라이싱은 리스트에서 여러 개의 데이터에 동시에 접근하는 기법이다.
  - `리스트명[시작_인덱스 : 종료_인덱스 : 스텝]`

```python
a = [4, 2, 7, 3, 5]
print(a[0 : 4 : 2]) # [4, 7]
```

- 0번지부터 4번지 바로 전 인덱스인 3번지 인덱스까지 2개씩 끊어서 슬라이싱

```python
l = [3, 5, 7]

l.append(3)
print(l) # [3, 5, 7, 3]

l.insert(2, 4)
print(l) # [3, 5, 4, 7, 3]

l.remove(3)
print(l) # [5, 4, 7, 3] (3이 여러 개이므로 가장 앞에 있는 3을 제거)

print(l[ : 2]) # [5, 4]
```

- 튜플형

  - 튜플형은 초기에 선언된 값에서 값을 생성, 삭제, 수정이 불가능한 형태의 자료형이다.
  - `튜플형 = (요소1, 요소2, ...)`
  - 튜플은 여러 값으로 이루어져 있는데 인덱스를 이용해서 중간값에 접근할 수 있다.

- 딕셔너리형
  - 딕셔너리형은 키와 값으로 구성된 객체를 저장하는 구조로 되어 있는 자료형이다.
  - `딕셔너리명 = {키1: 값1, 키2: 값2}`

## 식별자

- 식별자는 변수, 상수, 함수 등 서로 구분하기 위해서 사용되는 이름이다.
- 프로그램의 구성요소를 구별하기 위해 사용한다.

### 식별자 표기법

1. 카멜 표기법: inputFunction
2. 파스칼 표기법: InputFunction
3. 스네이크 표기법: input_function
4. 헝가리안 표기법: 식별자 표기 시 두어에 자료형을 붙이는 표기법. int형일 경우 n, char일 경우 c, 문자열일 경우 sz를 붙임 (nScore)

## 연산자

- 파이썬에서는 증감 연산자를 지원하지 않는다.

### 비트 연산자

- 비트 연산자는 0과 1의 각 자리에 대한 연산을 수행하는 연산자이다.
- `&`: 두 값을 비트로 연산하여 같은 비트의 값이 모두 1이면 해당 비트 값이 1이 되고, 그렇지 않으면 0
- `|`: 두 값을 비트로 연산하여 같은 비트의 값이 하나라도 1이면 해당 비트 값이 1이 되고, 그렇지 않으면 0
- `^`: 두 값을 비트로 연산하여 같은 비트의 값이 서로 다르면 해당 비트 값이 1이 되고, 그렇지 않으면 0
- `~`: 모든 비트의 값을 반대로 바꾸는 반전 기능을 하는 연산자

## 출력 함수

### C언어

- 단순 출력 : `printf(문자열);`
- printf를 사용하기 위해서는 stdio.h 헤더(stdio는 표준 입출력인 Standard Input Output의 약자)를 선언해야 한다.

```c
#include <stdio.h>
void main() {
  printf("Hello C World)
}
```

- printf 사용하기 위해 stdio.h 헤더를 선언
- main은 소스 코드 실행 시 시작 위치
- printf 안에 있는 문자열을 출력

- C언어에만 해당하는 사항으로 변수에 저장된 값을 출력할 때는 printf라는 함수를 쓰고, printf 내에서 포맷 스트링을 통해 변수 출력 방식을 결정한다.

- 포맷 스트링

  |        |                                      |             |
  | ------ | ------------------------------------ | ----------- |
  | 유형   | 포맷 스트링                          | 설명        |
  | 문자형 | `%c`                                 | 문자 출력   |
  | 문자형 | `%s`                                 | 문자열 출력 |
  | 정수형 | `%d`                                 | 10진수 출력 |
  | 정수형 | `%x`                                 | 16진수 출력 |
  | 정수형 | `%o`                                 | 8진수 출력  |
  | 실수형 | `%f` `%[전체자리수].[소수점자리수]f` | 실수 출력   |

- C언어에서 2진수를 출력하는 포맷 스트링은 존재하지 않는다.

```c
#include <stdio.h>
void main() {
  char a = "A";
  int b = 10;
  printf("%c %d", a, b); // A 10
}
```

```c
#include <stdio.h>
void main() {
  float a = 1.2;

  printf("%f\n", a); // 가공하지 않고 출력(float는 소수 6자리 출력)
  printf("%.2f\n", a); // 소수점 2자리만 출력
  printf("%7.3f\n", a); // 소수점 포함 7글자 출력, 소수점 3자리 출력(1, 200)은 총 5글자이므로 앞에 2글자 공백

  // 1.200000
  // 1.20
  //   1.200
}
```

### C++

- 단순 출력 : `std::cout << 문자열`
- cout를 사용하기 위해서는 iostream 헤더를 선언해야 한다.
- using namespace std;를 선언하면 cout를 사용할 때 std:: 부분을 생략할 수 있다.

```c
#include <iostream>
using namespace std;
void main() {
  cout << "Hello World";
}
```

- 개행 : `std::endl;`
- endl을 사용하기 위해서는 iostream 헤더를 선언해야 한다.

```c
#include <iostream>
using namespace std;
void main() {
  cout << "Hello" << endl << "World"; // 중간에 endl을 만나면 개행
}
```

- 변수 출력 : `std::cout << 변수명;`
- 변수에 저장된 값을 출력할 때는 `printf`라는 함수를 쓰고, `printf` 내에서 포맷 스트링을 통해 변수 출력 방식을 결정한다.
- 출력하는 포맷 스트링은 존재하지 않는다.

### 자바

- 단순 출력

  - `System.out.printf(문자열);` : C언어처럼 포맷 스트링을 사용하여 변수를 출력할 수 있는 출력 함수
  - `System.out.print(문자열);` : 출력 후에 개행을 하지 않는 함수

- 개행
  - `System.out.print("\n");`
  - `System.out.println(문자열);`

### 파이썬

- 단순 출력 및 개행
  - `print(문자열)` : print 함수를 쓰면 함수가 종료된 후에 기본으로 개행이 된다.
  - `print(문자열, end=" ")` : 출력 후에 개행을 하지 않음

## 입력 함수

### C언어

- 변수값 입력 : `scanf(포맷_스트링, &변수명)`
- 문자열 입력 : `scanf("%s", 배열명);`
- `scanf`를 사용하기 위해서는 stdio.h 헤더를 선언해야 한다.
- 문자열을 입력받는 경우가 아니라면 변수명 앞에 &를 붙인다.
- 문자열을 입력받는 경우 배열명을 쓰고 &는 안 붙인다
  - 변수형 앞에 &를 붙이는 이유는 주솟값을 나타내기 위함(포인터)이다. 배열은 배열명만 적었을 경우 배열명 자체가 주솟값이므로 &를 붙이지 않는다.

```c
#include <stdio.h>
void main() {
  char a;
  int b;
  scanf("%c %d", &a, &b);
  printf("%c %d", a, b);
}
```

- 입력을 A 10으로 할 경우 -> A 10 출력

### C++

- `std:cin >> 변수명;`
- cout를 사용하기 위해서는 iostream 헤더를 선언해야 한다.
- using namespace std;를 선언하면 cout를 사용할 때 std:: 부분을 생략할 수 있다.

```c
#include <iostream>
using namespace std;
void main() {
  char a;
  int b;
  cin >> a >> b;
  cout << a << b;
}
```

- 입력을 A 10으로 할 경우 -> A 10 출력

### 자바

Scanner 클래스를 스캐너 변수에 생성한 후, 스캐너 변수를 이용해 정수형일 경우 nextInt, 실수형일 경우 nextFloat, nextDouble, 문자열일 경우 nextLine을 통해 입력받는다.

- 정수형 입력
  - `Scanner 스캐너_변수명 = new Scanner(System.in);`
  - `입력받을_변수명 = 스캐너_변수명.nextInt();`
- 실수형 입력
  - `Scanner 스캐너_변수명 = new Scanner(System.in);`
  - `입력받을_변수명 = 스캐너_변수명.nextFloat();`
- 문자열 입력
  - `Scanner 스캐너_변수명 = new Scanner(System.in);`
  - `입력받을_변수명 = 스캐너_변수명.nextLine();`

```java
public static void main(String[] args) {
  String s;
  int i;
  float f;

  Scanner c = new Scanner(System.in);
  s = c.nextLine();
  System.out.printls(s);

  i = c.nextInt();
  System.out.println(i);

  f = c.nextFloat();
  System.out.println(f);
}
```

- 입력
  - Hello
  - 5
  - 4.7
- 출력
  - Hello
  - 5
  - 4.7

### 파이썬

- 파이썬에서는 정수형과 실수형과 같은 숫자를 입력받을 때는 문자열로 저장한 후에 eval 함수를 써서 숫자로 변환해 주어야 한다.
- eval 매개변수를 숫자로 변환할 수 없는 형태의 문자열일 경우 에러가 발생 한다.
- 문자열 입력 : `변수명 = input()`
- 숫자 입력
  - `변수명 = input()`
  - `변수명 = eval(변수명)`

## 조건문

- 파이썬에서는 switch문을 지원하지 않음

### C언어 if문 사용 예제

```c
#include <stdio.h>
void main() {
  int score;
  scanf("%d", &score);

  if (score % 2 == 0) {
    printf("짝수");
  }
  else {
    printf("홀수");
  }
}
```

### 파이썬 if문 사용 예제

```python
if 조건문 :
  명령문
elif 조건문 :
  명령문
else :
  명령문
```

## 반복문

### C언어 for문 예제

```c
  #include <stdio.h>
  void main() {
    int i = 0;
    int sum = 0;

    for (i = 1; i <= 10; i++)
      sum = sum + i;

    printf("%d\n", sum);
  }
```

### 파이썬 for문 예제

```python
  i = 0
  sum = 0

  for i in range (1, 11) : # i = 1부터 10까지 반복
    sum = sum + i

  print(sum)
```

---

# 사용자 정의 자료형 활용

- 사용자 정의 자료형은 사용자가 상황에 맞게 기존 자료형들을 조합해 만드는 자료형이다.
- 사용자 정의 자료형에는 열거체, 구조체가 있다.

## 열거체

- 열거체는 서로 연관된 정수형 상수들의 집합이다.
- 정수형 상수에 이름을 붙여서 코드를 이해하기 쉽게 해준다.
- C, C++에서는 멤버에 초깃값을 설정하지 않으면 0부터 차례대로 할당된다.

```
  enum 열거체명 {
    멤버1,
    멤버2,
    ...
  }
```

### C++ enum 사용 예시

```c
#include <iostream>

enum Week {
  Sunday,
  Monday,
  Tuesday = 5,
  Wednesday
};
// Sunday는 초깃값이 설정되지 않아 0, Monday는 1, Wednesday는 6으로 설정된다.

void main() {
  enum Week week; // Week타입의 week 변수 선언
  week = Wednesday;
  std::cout << week; // week 변수에 저장된 값 Wednesday에 해당하는 값인 6을 출력
}
```

- 자바는 `Tuesday = 5`처럼 값을 대입할 수 없고, `System.out.print(week);`라고 했응ㄹ 경우 Tuesday라고 출력된다.
- 파이썬에서 `class Week(Enum): Sunday=0` 이라고 선언하고 `print(Week.Sunday)`로 출력할 경우 Week.Sunday가 출력된다.

## 구조체

- 구조체는 사용자가 기본 타입을 가지고 새롭게 정의할 수 있는 사용자 정의 자료형이다.
- 자바, 파이썬에서는 지원 X (class를 이용해 struct 기능을 구현할 수는 있음)

### C, C++에서 사용하는 struct

```c
struct 구조체명{
  자료형 변수명1;
  자료형 변수명2;
  ...
}
```

### C++ 구조체 사용 예시

```c
#include <iostream>
using namespace std;

struct Student {
  char gender;
  int age;
  int num;
};

void main() {
  struct Student s; // struct Student라는 타입의 s라는 이름의 변수 선언
  s.gender = "M";
  s.age = 24;
  s.num = 2020202020;
}
```

# 사용자 정의 함수

### C, C+=, 자바에서 사용하는 사용자 정의함수

```c
반환_데이터_타입 함수명(데이터_타입 변수명, ....) {
  명령어;
  return 반환값;
}
```

```c
  #include <stdio.h>

  char fn(int num) {
    if (num % 2)
      return "Y";
    else
      return "N";
  }

  void main() {
    char a = fn(5);
    printf("%c\n", a);
  }
```

### 파이썬 사용자 정의함수

```python
  def 함수명(변수명, ...) :
    명령어
    return 반환값
```

# 클래스

- 클래스는 객체지향 프로그래밍 (OOP Object Oriented Programming)에서 특정 객체를 생성하기 위해 변수와 메서드를 정의하는 틀이다.
- C언어는 명령형 프로그래밍으로 클래스를 지원하지 않는다.

## 접근 제어자(Access Modifier)

접근 제어자는 지정된 클래스 변수, 메서드를 외부(같은 패키지이거나 다른 패키지)에서 접근할 수 있도록 권한을 설정하는 기능

- public
  - 외부의 모든 클래스에서 접근 가능한 접근 제어자
- protected
  - 같은 패키지 내부에 있는 클래스, 하위 클래스(상속받은 경우)에서 접근이 가능한 접근 제어자
  - 자기 자신과 상속받은 하위 클래스 둘 다 접근이 가능한 접근 제어자
- default
  - 접근 제어자를 명시하지 않은 경우로 같은 패키지 내부에 있는 클래스에서 접근이 가능한 접근 제어자
  - 자바에만 존재
- private
  - 같은 클래스 내에서만 접근 가능한 접근 제어자

## 클래스 정의

- 클래스는 변수와 메서드(함수) 형태로 구성되어 있다.
- 클래스에서 변수는 변수 선언과 동일하고, 메서드는 사용자 정의함수와 문법이 동일하다.
- 파이썬은 별도로 변수 선언을 하지 않기 때문에 메서드 형태로 구성되어 있다.

### C++ 클래스 정의

```c
  class 클래스명 {
    private:
      변수_타입 변수명;
    public:
      반환_데이터_타입 메서드명(데이터_타입 변수명, ...) {
        명령어;
        return 반환값
      }
  }
```

### 자바 클래스 정의

```java
  public class 클래스명 {
    private 변수_타입 변수명;
    public 반환_데이터_타입 메서드명(데이터_타입 변수명, ...) {
      명령어;
      return 반환값;
    }
  }
```

### 파이썬 클래스 정의

```python
  class 클래스명:
    def 메서드명(self, 변수명, ...) {
      명령어
      return 반환값
    }
```

- 파이썬에서는 함수명에 입력받을 값(매개 변수) 앞에 `self`라는 키워드를 적어야 한다.

## 자신 클래스 참고

### this 포인터

- this 포인터는 현재 객체를 가리키는 포인터이다.
- C++, 자바에서 사용하는 것으로 클래스 내부의 변수와 함수를 가리킬 수 있다.

### C++ this 포인터

```c
  this -> 변수명;
  this -> 함수명(매개변수);
```

```c
#include <iostream>

class A {
  private:
    int a;
  public:
    void setA(int a) {
      this -> a = a;
    }

    int getA() {
      return a;
    }
}

void main() {
  A* a = new A();
  a -> setA(5);
  std::cout << a -> getA();
  delete a; // a 변수 메모리 해제
}
```

### 자바 this 포인터

```java
  this.변수;
  this.함수(매개변수);
```

```java
public class A{
  private int a;
  public void setA(int a) {
    this.a = a;
  }
  public int getA() {
    return a;
  }

  public static void main(String[] args) {
    A a = new A();
    a.setA(5);
    System.out.print(a.getA());
  }
}
```

- 보통은 매개변수로 받는 값과 클래스 내의 변수명을 구분하기 위해 this를 사용한다.

### 파이선 예제

- 파이썬에서는 self를 이용한다. self는 현재 객체를 가리키는 포인터이다.

## 클래스 선언

- 클래스를 일반변수로 선언한 경우 선언함과 동시에 생성자가 호출되고, 일반변수로 선언한 곳에서 함수가 종료되면 소멸자가 호출된다.
- 클래스를 포인터 변수로 선언한 경우 new 키워드를 이용해 선언함과 동시에 생성자가 호출되고, delete 키워드를 이용해 해당 변수의 저장 공간을 삭제하면 소멸자가 호출된다.

### C++ 클래스 선언

- 일반변수
  - `클래스 클래스변수(매개변수);` // 생성시
  - `클래스변수.메서드(매개변수);` // 클래스 내 메서드 사용
- 포인터 변수 사용

  - `클래스* 클래스 변수 = new 클래스(매개변수);`
  - `클래스변수 -> 메서드(매개변수);`
  - `delete 클래스변수;`

- C++에서는 일반변수를 사용하면 점을 이용해 메서드에 접근하고, 포인터 변수를 사용하면 화살표를 이용해 메서드에 접근한다.

### 자바 클래스 선언

```java
  클래스 클래스변수 = new 클래스(매개변수); // 생성시
  클래스변수.finalize(); // 소멸시
```

### 파이썬 클래스 선언

```python
  클래스변수 = 클래스(매개변수) # 생성시
  del 클래스변수 # 소멸시
```

## 생성자(Constructor)

- 생성자는 해당 클래스의 객체가 생성될 때 자동으로 호출되는 특수한 종류의 메서드이다.
- 생성자는 일반적으로 클래스의 멤버 변수를 초기화하거나 클래스를 사용하는 데 필요한 설정이 필요한 경우 사용한다.
- C++, 자바에서는 클래스 명과 동일한 메서드명을 가지고, 반환 값이 없다.
- 파이썬에서는 `__int__`라는 메서드명을 사용하고, 첫 번째 매개변수로 `self`를 적어주며, 반환 값이 없다.

### C++에서 사용하는 생성자

```c
class 클래스명 {
  public:
    클래스명(데이터_타입 변수명, ...) {
      명령어;
    }
}
```

### 파이썬에서 사용하는 생성자

```python
class 클래스명:
  def __int__(self, 변수명, ...):
    명령어
```

## 소멸자(Destructor)

- 소멸자는 객체의 수명이 끝났을 때 객체를 제거하기 위한 목적으로 사용되는 메서드이다.
- C++에서는 클래스명과 동일한 메서드명을 가지고 `~`기호를 사용하며, 입력값(매개변수)과 반환 값이 없다.
- 자바에서는 `finalize`라는 메서드를 사용, 반환 값 X
- 파이썬에서는 `__del__`라는 메서드 사용, 첫 번째 매개변수에 `self`를 적어주며 반환 값 X

### C++에서 사용하는 소멸자

```c
class 클래스명 {
  public:
    ~클래스명() {
      명령어;
    }
}
```

### 자바에서 사용하는 소멸자

```java
public class 클래스명 {
  public void finalize(매개변수) {
    명령어;
  }
}
```

### 파이썬에서 사용하는 소멸자

```python
class 클래스명:
  def __del__(self):
    명령어
```

## 상속(Inheritance)

### C++ 상속

```c
class 부모_클래스명 {
};

class 자식_클래스명 : public 부모_클래스명 {
};
```

### 자바 상속

```java
class 부모_클래스명 {
}

class 자식_클래스명 extends 부모_클래스명 {
}
```

### 파이썬 상속

```python
class 부모_클래스명:

class 자식_클래스명(부모_클래스명):
```

## 오버로딩(Overloading)

- 오버로딩은 동일 이름의 메서드를 매개변수만 다르게 하여 여러 개 정의할 수 있는 기능이다.
- 파이썬에서는 지원 X

### 오버로딩 특징

- 메서드 이름이 같아야 한다.
- 매개변수 개수가 달라야 한다.
- 매개변수 개수가 같을 경우 데이터 타입이 달라야 한다.
- 반환형은 같거나 달라도 됨

## 오버라이딩(Overriding)

- 오버라이딩은 하위 클래스에서 상위 클래스 메서드를 재정의할 수 있는 기능이다
- C++에서는 virtual 키워드가 있어야 오버라이딩이 가능하다.

### 오버라이딩 특징

- 오버라이드하고자 하는 메서드가 상위 클래스에 존재하여야 한다.
- 메서드 이름은 같아야 한다.
- 메서드 매개변수 개수, 데이터 타입 같아야 함
- 메서드 반환형이 같아야 한다.

### C++ 오버라이딩

```c
class 부모_클래스명 {
  public:
    virtual 반환_데이터_타입 메서드명(데이터_타입 변수명) {
    }
}

class 자식_클래스명 {
  public:
    virtual 반환_데이터_타입 메서드명(데이터_타입 변수명) {
      // 부모 클래스의 메서드명, 매개변수 동일해야 한다.
    }
}
```

- C++에서 메서드에 `virtual` 키워드를 선언할 경우 자식 클래스에 같은 이름의 메서드가 있을 때 오버라이딩 된다.

## 상위 클래스 접근

C++은 콜론 두 번(::), 자바와 파이썬은 super 키워드를 이용하여 상위 클래스의 변수나 메서드에 접근할 수 있다.

- C++
  - `부모_클래스::메서드명()`
- 자바
  - `super.메서드명()`
- 파이썬
  - `super().메서드명()`

## 추상 클래스

추상 클래스는 미구현 추상 메서드를 한 개 이상 가지며, 자식 클래스에서 해당 추상 메서드를 반드시 구현하도록 강제하는 기능이다.

### C++ 추상 클래스

```c
class 클래스명 {
  public:
    virtual 데이터_타입 메서드명() = 0;
}
```

### 자바 추상 클래스

```java
abstract class 클래스명 {
  abstract 데이터_타입 메서드명();
}
```

### 파이썬 추상 클래스

```python
class 클래스명:
  def 메서드명(self):
    pass
```

- 파이썬에서 메서드나 함수 내부에서 아무것도 실행하지 않을 경우 pass 명령을 써줘야 한다.

## 인터페이스

- 인터페이스는 자바의 다형성을 극대화하여 개발코드 수정을 줄이고 프로그램 유지보수성을 높이기 위한 문법이다. (인터페이스는 일종의 추상 클래스이다.)
- 오직 추상 메서드와 상수만을 멤버로 가질 수 있으며, 그 외의 다른 어떠한 요소도 허용하지 않는다.
- 인터페이스는 구현된 것은 아무것도 없고 밑그림만 그려져 있는 "기본 설계도"라고 할 수 있다.

### 자바 인터페이스

```java
interface 클래스명 {
  데이터_타입 메서드명();
}
```

```java
interface A {
  void fn();
}

class B implements A {
  public void fn() {
    system.out.println("B");
  }
}

class C implements A {
  public void fn() {
    System.out.println("C");
  }
}

class MainTest {
  public static void main(String args[]) {
    A b = new B();
    A c = new C();
    b.fn();
    c.fn();
  }
}
```

## 객체지향 프로그래밍

- 절차지향의 단점을 보완하기 위해 생긴 패러다임. 절차지향은 프로그램을 단계적인 절차로 구성. 함수(프로시저)와 데이터를 서로 다른 요소로 취급한다. 객체지향에서는 데이터와 그 데이터를 조작하는 함수들을 하나의 독립적인 개체로 캡슐화하고, 객체 간의 상호작용을 통해 데이터를 조작한다. 이를 통해 함수 간의 결합도가 낮아지고, 데이터의 보호와 은닉화,코드의 재사용성, 유연성, 확장성이 개선된다.
- 객체지향 프로그래밍의 경우에는 객체와 객체 간의 통신을 통해 프로그램이 구현된다.
- 객체와 속성, 메서드로 구성되는데, 절차 지향에서의 모듈은 객체에 대응되고, 변수는 속성에 대응되며, 함수는 메서드에 대응된다.

### 객체지향 프로그래밍의 구성요소

객체지향 프로그래밍은 객체, 클래스, 메시지를 이용해 개발하는 방식

- 객체(Object)
  - 개체, 속성, 메서드로 구성된 클래스의 인스턴스를 의미
- 클래스
  - 객체지향 프로그래밍에서 객체를 표현하는 추상 데이터 타입으로 객체를 생성하는 틀
  - 클래스를 통해 추상화된 자료형을 제공
- 메시지
  - 객체 간의 통신

### 객체의 구성요소

객체는 현시 세계에서 개체를 데이터 속성과 메서드를 결합한 형태로 표현한 것을 의미

- 개체(Entity)
  - 현실 세계에 보이는 본질을 의미
- 속성
  - 자료 저장소 역할을 하며, 절차 지향 프로그래밍의 변수와 대응
- 메서드
  - 호출 단위를 의미, 절차 지향 프로그래밍의 함수와 대응

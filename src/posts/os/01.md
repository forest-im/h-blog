---
title: os
tag: JS, 객체, 책, 모던 자바스크립트
date: 2023-01-02 21:21:54
published: false
---

## os가 하는 일

- 가장 기본적인 일 : 프로세스를 관리하는 일

# 프로세스

- 프로세스란? 비공식적으로, 프로세스란 실행중인 프로그램
  - 프로그램 그 자체는 프로세스가 아니다. 프로그램은 명령어 리스트를 내용으로 가진 디스크에 저장된 파일 (실행파일)과 같은 수동적인 존재.
  - 이와는 대조적으로 프로세스는 다음에 실행할 명령어를 지정하는 프로그램 카운터와 관련 자원의 집합을 가진 능동적인 존재
  - **실행 파일이 메모리에 적재될 때 프로그램은 프로세스가 된다.** (프로그램이 메모리에 적재된다 : 프로그램이 실행된다.) (프로그램이 실행되고 있다 : 프로그램이 CPU를 할당받고 명령을 수행하고 있다.)

## pcb

## context switch

## 동시성 (concurrent) 제어

https://thewavelet.tistory.com/36

## 키워드

- 커널
- operating system
- 시스템 프로그램
- 응용 프로그램
- 스위치
- 트랜지스터
- 부트스트랩 (운영체제를 발에 쏙 집어넣는 역할)
- i/o (주변장치) - i/o 요청(버튼 클릭 등) cpu와 프로세서, i/o디바이스가 통신하는 방법 (클릭한 걸 알려줘야 한다.)
  - 하드웨어가 인터럽트를 트리거 시킬 수 있다. (시스템 버스를 통해서)
- 시스템 버스
- 폰노이만 아키텍처
- 튜링 머신

운영체제란
operating system
컴퓨터 하드웨어를 관리하는 것
컴퓨터 시스템을 운영하는 소프트웨어

운영체제가 서비스를 제공해주는 역할

컴퓨터는
information -> 정보를 처리하는 기계

정보란?

binary digit
정보의 최소 단위 : bit

스위치를 만들 수 있는 물리적인 소자: 트랜지스터
부울 대수(Boolean Algebra): NOT, AND, OR
논리 게이트: NOT, AND, OR, XOR, NAND, NOR
논리 회로

- 무어의 법칙, 황의 법칙

# 컴퓨터

앨런 튜링 Alan Turing - 튜링 머신

존 폰 노이만 (실제로 동작하는 컴터를 만듬)
내장형 stored-program computer를 처음 설계 -> 폰 노이만 아키텍처 ISA (명령어 집합으로 컴터를 운영하는 것)

- instruction-execution cycle 으로 정의
- instruction set : 컴퓨터에 내릴 수 있는 명령 집합
  - 이 명령 집합으로 이루어진 컴터 프로그램 (메모리에 잇는 명령어들을 cpu가 하나씩 fetch..)
- fetch를 실행하는 아키텍처, fetch -> 실행(executed)
- **instruction register** : IR
  프로그램을 램에 저장할 수 있다.

## 프로그램

명령어들의 집합
어셈블리어

computability : 계산 가능성
turing-computatble: 튜링 머신으로 계산가능한 것

## 운영체제 (operating system)

- 컴터 시스템을 운영한당 하드웨어를 제어할 수 있는 운영체제 -> 애플리케이션 관리를 운영체제가 다 한다.
- 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 수행한다.
- 컴퓨터의 관점에서 운영체제는 하드웨어와 가장 밀접하게 연관된 프로그램이다. 따라서 운영체제를 자원 할당자로 볼수 있다.
- 운영체제는 제어 프로그램이다. 제어 프로그램은 컴퓨터의 부적절한 사용을 방지하기 위해 사용자 프로그램의 수행을 제어한다. 운영체제는 특히 입출력 장치의 제어와 작동에 깊이 관여한다.
- 일반적으로 운영체제에 대한 적합한 정의는 없다. 운영체제는 유용한 컴퓨팅 시스템을 만드는 문제를 해결할 수 있는 합리적인 방법을 제공하기 때문에 존재한다. 컴퓨터 시스템의 기본 목표는 프로그램을 실행하고 사용자 문제를 더욱 쉽게 해결할 수 있게 하는 것이다.

1960년 무어의 법칙

### 운영체제도 프로그램의 일종인가?

- ㅇㅇ

## 커널 : 컴퓨터에서 항상 실행되는 프로그램

커널 부분이 운영체제의 핵심

## 저장장치

레지스터 -> 엄청나게 빠름

## 멀티프로그래밍

여러개의 프로그램을 메모리에 동시에 올리는 것

- 하나의 프로그램이 한번에 한 개 이상이 돌고있는 것
- 메모리에 여러 개의 프로세스가 동시에 올라가있으면 CPU 사용 효율을 올릴 수 있다.

## 멀티태스킹(=multiprocessing) -> conurrency, pallelelsim

### CPU scheduling

## 시스템 프로그램: 반드시 커널의 일부일 필요는 없는 것

## 응용 프로그램: 시스템 작동과 관련되지 않은 모든 프로그램을 포함하는 것

컴퓨터 시스템

1. 하드웨어
2. 운영체제
3. 응용 프로그램
4. 사용자

## 컴퓨터 시스템의 구성

현대의 범용 컴퓨터 시스템은 하나 이상의 CPU, 구성요소 그리고 공유 메모리 사이의 액세스를 제공하는 공통 **버스** 를 통해 연결된 여러 **장치 컨트롤러** 로 구성된다.
일반적으로 운영체제에는 각 장치 컨트롤러마다 장치 드라이버가 있다.

## 시스템 버스

컴퓨터 시스템에는 많은 버스가 있을 수 있지만 시스템 버스는 주요 구성요소 사이의 주요 통신 경로이다.

## 인터럽트

- 일반적인 컴퓨터 작업: 입출력을 수행하는 프로그램
- 입출력 작업을 시작하기 위해 장치 드라이버는 장치 컨트롤러의 적절한 레지스터에 값을 적재한다.
- 컨트롤러는 장치 드라이버에게 작업을 완료했다는 사실을 어떻게 알리는가? -> 인터럽트를 통해 이루어진다.

하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있다.
인터럽트는 다른 많은 목적으로도 사용되며 운영체제와 하드웨어의 상호 작용 방식의 핵심 부분

인터럽트는 컴퓨터 구조의 중요한 부분이다. 각 컴퓨터 설계는 자신의 인터럽트 메커네이즘을 가지고 있으며 몇 가지 기능은 공통적이다.

인터럽트는 최신 운영체에서 비동기 이벤트를 처리하기 위해 사용된다.

## 저장장치 구조

cpu는 메모리에만 명령을 적재할 수 있다. 실행하려면 프로그램을 먼저 메모리에 적재해야 한다.
범용 컴퓨터는 프로그램 대부분을 메인 메모리(random-access memory 또는 RAM)가 불리는 재기록 가능한 메모리에서 가져온다. 메인 메모리는 dynamic random-access memory (DRAM)이라 불리는 반도체 기술로 구현된다.

컴터는 다른 형태의 메모리도 사용. 컴터 전원 킬 때 젤 먼저 실행되는 것 -> 운영체제가 적재된 부트스트랩
RAM은 휘발성 -> 부트스트랩 프로그램을 유지하는 용도로 사용할 수 없다. 이 목적과 다른 목적으로, 컴터는 전기적으로 소거 가능한 프로그램 가능 읽기 전용 메모리(EEPROM) 및 기타 형태의 펌웨어를 사용한다. EEPROM은 변경할 수는 있지만 자주 변경할 수는 없다. 속도가 느리므로 주로 사용되지 않는 정적 ㅍ로그램과 데이터가 포함되어 있다.

모든 형태의 메모리는 바이트의 배열을 제공한다. 각 바이트는 자신의 주소를 가지고 있다.

폰 노이만 구조 시스템 - 먼저 메모리로 부터 명령을 인출해 그 명령을 명령 레지스터에 저장한다.
메모리 장치는 단지 일련의 메모리 주소만을 인식한다. 메모리는 이들 주소, 색인, 간접 주소 등이 어떻게 생성되었는지 알지못한다.

- 메인 메모리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에는 너무 작다.
- 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성 장치이다.

-> 대부분의 컴터 시스템은 메인 메모리의 확장으로 보조저장장치를 제공한다. (대량의 데이터를 영구히 보존할 수 있어야 함)

- 하드 디스크 드라이브(HDD)
- 비휘발성 메모리 장치

대부분의 프로그램(시스템 및 응용 프로그램)은 메모리에 적재될 때까지 보조저장 장치에 저장된다. 그런 후 많은 프로그램이 보조저장장치를 처리 소스 및 대상으로 모두 사용한다.
보조저장장치도 메인 메모리보다 훨씬 느리다
레지스터, 메인 메모리 및 보조저장장치로 구성된 저장장치 구조 -> 많은 저장장치 시스템 설계 중 하나일 뿐

일반적으로 크기와 속도 사이에는 상충하는 측면이 있다. 메모리가 작고 빠를수록 CPU에 더 가깝다. 그리고 휘발성 또는 비휘발성이다.

- 메모리 -> 휘발성 저장장치 -> 단순하게 메모리라고 할 것
- NVS -> 전원이 꺼졌을 떄 내용을 유지한다. 이를 NVS라고 한다. 대부분의 경우 NVS는 보조저장장치를 가리킨다.
  1. 기계적. (예: HDD, 광 디스크, 홀로그램 저장장치 및 자기 테이프)
  2. 전기적. (예: 플래시 메모리, FRAM, NRAM 및 SSD)

### VMM (virtual machine manager)

시스템 콜

System lls

---

## 인터럽트

### 외부 인터럽트

- 전원 이상 인터럽트
- 기계 착오 인터럽트 (CPU의 기능적인 오류)
- 외부 신호 인터럽트
- 입출력 인터럽트
  - 입출력장치가 데이터 전송을 요구하거나 전송이 끝나 다음 동작이 수행되어야 할 경우
  - 입출력 데이터에 이상이 있는 경우

컴터 핵심은 cpu이다. 주기억장치 RAM과 밀접하게 연결되어 있음 예전엔 CPU가 직접 RAM을 다뤘지만 이젠 거의 메모리 매니저(소위 브릿지 칩셋이라고 불렀던 것)라는 것을 가지고 간적접으로 다룬다고 한다.

### 내부 인터럽트

- 잘못된 명령이나 잘못된 데이터를 사용할 때 발생하며 Trap이라 부른다.
- 프로그램 검사 인터럽트
  - Division by zero
  - Overflow/Underflow
  - 기타 Exception

### 소프트웨어 인터럽트 (SVC: SuperVisor Call)

인터럽트가 발생하면 하던 일을 멈춘다는 게 핵심

## 인터럽트 서비스 루틴

1. 인터럽트 요청
2. CPU 연산 중단 (일시정지)
3. 현재의 프로그램 상태 보존: PCB(Process Control Block), PC(Program Counter) (백업을 한다. )
   ...

## I/O 성능

Direct X
DMA
입출력 과정 -> 성능과 연관

## DMA direct

ram 영역 일부를 떼서 예약 (누구를 위해? 어떤 장치를 위해) 컴터의 메모리라고 하는 것은 cpu에도 있다. (캐시메모리 라는 것)

## 캐시 메모리

## CPU도 예측하고 미리 움직인다.

cpu : 연산장치 - (속도가 중요)

연산해야 할 데이터는 기본적으로 RAM에 있다.
램에 있는 걸 cpu로 옮기고 쓰고 다시 내려가고
속도차가 생각보다 크다.
cpu core에서 레지스터(cpu 안의 저장장치)

core 레지스터 속도 -> 1ns (나노세크)
ram -> 50ns
속도가 50배 차이
속도 차이가 많이 나서 완충 역할을 해주는 게 캐시 메모리
: cpu와 램 사이의 완충 장치 역할

```
+----+ +----+
|core| |core|
+----+ +----+
| L1 | | L1 |
+----+ +----+
| L2 | | L2 |
+----+ +----+
+-----------+
|     L3    |
+-----------+
```

- 캐시는 보통 코어에 붙어있다.
- 코어 4개가 있다면 각각의 코어마다 캐시..(제조사마다 다름)
- 보통 l3는 같이 쓴다.
- 속도 차이를 극복하는 역할을 한다. 완충 역할
- 데이터 양 때문에 나눠놓은 것

## GPU

- 코어 개수가 4000개..
- cpu보다 속도가 느리지만 코어 개수가 어마마
- cpu, gpu는 역할이 다른 것 즉 용도가 다르다.
- api에 많이 쓴다.

프로세스는 한 시스템 내의 작업의 단위이다.

## NVM

- 비휘발성 메모리 (Non-volatile memory)

시스템 프로그래밍..

## 가상화

관리의 단위
관리의 주체 : os

## 가상 메모리 virtual memory

가상 메모리 -> 하드디스크 같은 2차메모리를 주기억장치 램과 합쳐서 싸잡아서 하나의 메모리로 추상화 하자는 말

- 프로세스마다 독립적인 공간

vmware

- 하드웨어(NIC)도 소프트웨어로 구현함
  virtual nic drive
  (NIC : 랜카드 네트워크 인터페이스 컨트롤러)

## 프로세스 스레드

process (작업)는 최소 1개의 스레드(연산)가 존재한다.

- os는 virtual memory를 프로세스한테 할당한다 (프로세스한테 준다.)
- 하나의 vms를 스레드끼리 공유한다
  - **한 프로세스 안에 스레드가 여러 개 있다고 해도** 하나의 vms 공간을 수용함
- 프로세스에 속한 스레드는 프로세스의 가상 메모리로 공간이 제약된다.
- 스레드라는 것은 실질적 연산의 주체이다. (보통 연산은 스레드 단위로 실행된다.)
  - 스레드: 연산 단위
    cpu 자원을 선점하는 건 프로세스가 아닌 스레드
- 한 가구.. 라고 생각 보통 집이라고 하는 공간이 부여됨.
  - 한 가구 안에 세대원이 있을 것임
  - 방이 세 개라고 치면 (방은 각자쓰는 것) 방을 제외하고 거실 화장실은 공용공간
  - 집: 프로세스에 할당된 버추얼 메모리 공간
  - 세대원: 스레드 (개별 흐름)
  - 각자의 방: 스레드 로컬 스토리지 (기본적으로 스레드마다 스택구조로 관리되는 메모리 공간이 따로 있다.)
  - 거실: Heap
  - 부엌: 데이터 영역이라고 한다면 -> 전역 변수

### 멀티에는 꼭 동기화 이슈가 난다.

- 화장실: 화장실을 선점하려는 시도 -> 병목현상 발생, 예기치 못한 레이스 컨디션 발생

- 스레드마다 각자 고유한 tls (thread local storage) 를 갖고 있고 각자만의 자기 방을 가진다. 각자 모여살고 있는데 프로세스에게 운영체제가 제공한 공간으로 영역이 한정된다.

## 레이스 컨디션

### 왜 스레드를 나눌까?

### 멀티 스레딩

- +동시성 이슈
- +동기화 이슈

## Blocking I/O Non-Blocking I/O

### Blocking I/O

- Blocking I/O는 Synchronous다.
  - 함수를 반환할 때까지 다음으로 넘어가지 않고 기다리는 것

### Non-Blocking I/O

스레드에서 os에게 비동기처리를 하고 자기는 끝내버림

- os에게 넘김으로서 분리되는 것이 비동기
- 비동기는 화면을 멈춰놓을 일이 없다.

어떤 게 성능이 좋은지로 말할 수 없다.

- 결국 입출력의 주체는 운영체제가 한다.
- I/O 처리를 운영체제가 직접 하게되면 성능상의 이점을 말할 수는 있음
- 비동기는 언제 올지 모른다.

시간을 예측하기 위해서 단위를 만든다. (예측 가능한 단위로 만들어서)

동기화를 위해서 queue를 쓴다.
멀티스레드 환경에서 동기화를 위해서 큐라는 자료구조가 꼭 등장한다.
비동기 입출력 -> 멀티 스레딩이 안나오는 경우가 없당

### queue

### 디스패치

선택해서 꺼낸다.

윈도우는 스레드중심
리눅스는 프로세스중심

상태라는 게 있고 전이한다.

## sleep + suspend

### sleep

휴식

- 자발적

### suspend

보류

- 외부 요인 (os, 다른 프로세스..)에 의해서 강제로 그렇게 된 것
- 의도한 것이 아님. (중요)

suspend건 sleep이건 큐 줄에서 이탈하게 된다. 중간에서 빠져나갔다가 뒤로 재진입하게된다. 알파만큼의 시간 소요..

이어간당 + 문맥 (컨텍스트)
문맥교환 컨텍스트 스위칭

앞의 문맥을 이어가기 위해 상태를 저장한다. (PCB에)

실행: 연산 (연산을 하는 장치: cpu)
cpu에서 연산을 하며 상태가 변한다. 그 상태는 모두 레지스터에 기록되어 잇따.

### 프로그램 카운터

프로세서 제어 블록 (PCB) 찾아보기

## 프로세스 생성

가상메모리 중요중요

- 늘 따라다니는 것 -> Process (단위)

## Thread

- 스레드는 연산의 단위이다.
- 실제로 cpu라는 자원을 선점하는 것은 프로세스가 아닌 스레드가 선점한다.
- cpu core가 8개라고 했을 때 스레드에게 1개 또는 2개를 쓰라고 권한을 부여하는 것은 운영체제가 프로세스에게 부여한다.
- 스레드 = 레지스터 + 스택 + pc
  - 스택 -> 지역 + 자동변수 (스택은 굉장히 작다)
  - 레지스터 정보 : 스레드 컨트롤 블락이 따로 있다. TCB vs PCB
    - 스레드 단위로 실행 (다른 이름으로 연산 (연산은 core가))
    - 실행(연산) -> cpu core가 연산 연산을 하게되면 cpu core의 레지스터에 변화가 생긴다. -> Cpu 레지스터 상태를 백업했다가 다시 되돌리는 작업을 -> **Context Switching** **문맥교환**
- 프로세스와 마찬가지로 스레드도 **상태** 가 있다.

### 스레드를 왜 사용하나?

gui + 내부처리
이 둘은 각자 스레드로 분리하게 되어 있다.
각자 스레드로 나누게 되면 동기화하는 게 굉장히 중요

## 레이스 컨디션

## 레지스터

cpu가 요청을 처리하는데 필요한 데이터를 일시적으로 저장하는 공간

## 램

코어가 하나 -> 한순간에 오직 하나의 프로세스만이 실행될 수 있다. 나머지 프로세스는 CPU의 코어가 가용 상태가 되어 다시 스케줄 될 수 있을 때까지 기다려야 한다. 다중 프로그래밍의 목적은 cpu 이용률을 최대화하기 위해 항상 실행 중인 프로세스를 가지게 하는 데 있다.
어느 한수간에 다수의 프로세스를 메모리 내에 유지한다. 어떤 프로세스가 대기해야 할 경우, 운영체제는 cpu를 그 프로세스로부터 회수해 다른 프로세스에 할당한다. 하나의 프로세스가 대기해야 할 때마다, 다른 프로세스가 CPU 사용을 양도받을 수 있다. 이러한 종류의 스케줄링은 운영체제의 기본적인 기능이다. 거의 모든 컴퓨터 자원들은 사용되기 전에 스케줄된다.
자료를 담당

시분할의 목적은 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU코어를 빈번하게 교체하는 것이다. (각 프로그램이 동시에 실행되는 것처럼 보이게) 이를 위해 프로세스 스케줄러는 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택한다. 각 코어는 한 번에 하나의 프로세스를 실행할 수 있다. 현재 메모리에 있는 프로세스 수를 다중 프로그래밍 정도라고 한다.

https://www.youtube.com/watch?v=qk7pfIwcNSU
배치 단위 -> 페이지
가져온 프로세스에 메모리에 어떻게 올릴지
segment
페이지단위 메모리
램이 다 차면 다시 재배치 -> 하드로 옮긴다던가

### 페이지

물리주소 : 램

## 프로세스

- 관리의 단위 관리는 운영체제가
- 연산 거리

## 준비큐

스케줄링 큐
프로세스가 시스템에 들어가면 준비 큐에 들어가서 준비 상태가 되어 cpu 코어에서 실행되기를 기다린다. (일반적으로 연결 리스트)

새 프로세스는 처음에 준비큐에 놓인다. 프로세스는 실행을 위해 선택되거나 또는 디스패치 될 때까지 기다린다. 프로세스에 cpu코어가 할당되고 실행 상태가 되면, 여러 이벤트 중 하나가 발생할 수 있다. (p125)

1. 프로세스가 i/o 요청을 공표한 다음 i/o 대기 큐에 놓일 수 있다.
2. 프로세스는 새 자식 프로세스를 만든 다음 자식의 종료를 기다리는 동안 대기 큐에 놓일 수 있다.
3. 인터럽트 또는 타임 슬라이스가 만료되어 프로세스가 코어에서 강제로 제거되어 준비 큐로 돌아갈 수 있다.

처음 두 경우에는 프로세스가 결국 대기 상태에서 준비 상태로 전환된 다음 준비 큐에 다시 돌아간다. 프로세스는 종료될 때까지 이 주기를 계속한다. 종료 시점에 모든 큐에서 제거되고 pcb 및 자원이 반환된다.

프로세스는 수명주기 동안 준비 큐와 다양한 대기 큐를 이주한다. cpu 스키주럴의 역할은 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 cpu 코어를 할당하는 것이다. cpu 스케줄러는 cpu를 할당하기 위한 새 프로세스를 자주 선택해야 한다.

## 문맥 교환

인터럽트는 운영체제가 cpu 코어를 현재 작업에서 뺏어 내어 커널 루틴을 실행할 수 있게 한다. 이러한 연산은 범용 시스템에서는 자주 발생한다.
인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 문맥을 복구할 수 있도록 현재 실행 중인 프로세스의 현재 문맥을 저장할 필요가 있다. 이는 결국 프로세스를 중단 했다가 재개하는 작업이다. 문맥은 프로세스의 pcb에 표현된다.
문맥 교환이 진행될 동안 시스템이 유용한 일 x -> 문맥 교환 시간은 순수한 오버헤드이다. (하드웨어의 지원에 크게 좌우됨)

## 큐

새 프로세스는 처음에 준비 큐에 놓인다.
프로세스는 실행을 위해 선택되거나 또는 디스패치 될 때까지 기다린다. 프로세스에 CPU코어가 할당되고 실행 상태가 되면, 여러 이벤트 중 하나가 발생할 수 있다.